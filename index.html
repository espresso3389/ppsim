<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EcoSim V20 - Interactive Map Editor</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Roboto, monospace; color: #ccc; }
        canvas { display: block; cursor: crosshair; }
        
        /* HUD */
        #hud { position: absolute; top: 15px; left: 15px; background: rgba(10, 10, 10, 0.8); border: 1px solid #333; border-radius: 6px; padding: 10px 15px; pointer-events: none; user-select: none; display: flex; flex-direction: column; gap: 5px; font-family: 'Courier New', monospace; font-weight: bold; z-index: 50; box-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        .hud-row { display: flex; justify-content: space-between; min-width: 180px; }
        .hud-label { display: flex; align-items: center; gap: 8px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
        .dot-prey { background: #00ccff; box-shadow: 0 0 5px #00ccff; }
        .dot-pred { background: #ff2222; box-shadow: 0 0 5px #ff2222; }
        .hud-fps { font-size: 0.8rem; color: #666; margin-top: 5px; border-top: 1px solid #333; padding-top: 5px;}

        /* GRAPH */
        #graph-container { position: absolute; bottom: 15px; left: 15px; width: 300px; height: 100px; background: rgba(10, 10, 10, 0.8); border: 1px solid #333; border-radius: 6px; z-index: 40; pointer-events: none; }
        #graphCanvas { width: 100%; height: 100%; display: block; border-radius: 6px; }

        /* TOOLBAR */
        #toolbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.95); border: 1px solid #444; border-radius: 8px;
            display: flex; gap: 5px; padding: 5px; z-index: 60;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
        }
        .tool-btn {
            width: 40px; height: 40px; border: 1px solid transparent; background: #333;
            border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem; color: #fff; transition: all 0.2s;
        }
        .tool-btn:hover { background: #444; }
        .tool-btn.active { background: #0055aa; border-color: #0077cc; box-shadow: 0 0 8px #0055aa; }

        /* CONTROLS */
        #controls-btn { position: absolute; top: 15px; right: 15px; padding: 8px 16px; background: #333; border: 1px solid #555; color: #fff; cursor: pointer; border-radius: 4px; z-index: 60; font-size: 0.8rem; text-transform: uppercase; }
        #controls-btn:hover { background: #444; }

        #panel { position: absolute; top: 0; right: 0; width: 300px; height: 100vh; background: rgba(12, 12, 12, 0.98); border-left: 1px solid #333; display: flex; flex-direction: column; box-shadow: -5px 0 20px rgba(0,0,0,0.8); transition: transform 0.3s ease; transform: translateX(100%); overflow-y: auto; z-index: 55; }
        #panel.open { transform: translateX(0); }
        .header { padding: 15px; background: #181818; border-bottom: 1px solid #333; }
        .header h2 { margin: 0; font-size: 0.9rem; color: #eee; text-transform: uppercase; }
        .content { padding: 15px; padding-bottom: 50px; }
        .section { margin-bottom: 20px; border-bottom: 1px solid #222; padding-bottom: 10px; }
        .section-title { font-size: 0.7rem; color: #666; text-transform: uppercase; margin-bottom: 10px; font-weight: bold; }
        .control-group { margin-bottom: 10px; }
        .control-label { display: flex; justify-content: space-between; font-size: 0.8rem; margin-bottom: 3px; color: #bbb; }
        .val-display { color: #00ccff; font-family: monospace; }
        
        input[type=range] { width: 100%; height: 4px; background: #333; border-radius: 2px; appearance: none; cursor: pointer; }
        input[type=range]::-webkit-slider-thumb { appearance: none; width: 14px; height: 14px; background: #00ccff; border-radius: 50%; cursor: pointer; border: 1px solid #000; }
        
        .btn-row { display: flex; gap: 10px; margin-top: 20px; }
        button.action-btn { flex: 1; padding: 10px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 0.8rem; text-transform: uppercase; color: #fff; }
        .btn-blue { background: #0055aa; } .btn-blue:hover { background: #0066cc; }
        .btn-gray { background: #333; } .btn-gray:hover { background: #444; }
    </style>
</head>
<body>

    <div id="hud">
        <div class="hud-row"><div class="hud-label"><span class="dot dot-prey"></span> Prey</div><span id="dispPrey">0</span></div>
        <div class="hud-row"><div class="hud-label"><span class="dot dot-pred"></span> Preds</div><span id="dispPred">0</span></div>
        <div class="hud-fps">FPS: <span id="dispFps" style="color:#fff">0</span></div>
    </div>

    <div id="graph-container"><canvas id="graphCanvas" width="300" height="100"></canvas></div>

    <div id="toolbar">
        <div class="tool-btn active" id="tool-pan" onclick="setTool('pan')" title="Pan/Move Camera">✋</div>
        <div class="tool-btn" id="tool-prey" onclick="setTool('prey')" title="Add Prey" style="color:#00ccff">●</div>
        <div class="tool-btn" id="tool-pred" onclick="setTool('predator')" title="Add Predator" style="color:#ff2222">●</div>
        <div class="tool-btn" id="tool-rock" onclick="setTool('rock')" title="Add Rock">⬛</div>
        <div class="tool-btn" id="tool-food" onclick="setTool('food')" title="Add Food" style="color:#00aa00">♣</div>
        <div class="tool-btn" id="tool-erase" onclick="setTool('erase')" title="Eraser">✖</div>
    </div>

    <button id="controls-btn" onclick="togglePanel()">Settings</button>

    <div id="panel">
        <div class="header"><h2>Parameters</h2></div>
        <div class="content">
            
            <div class="section">
                <div class="section-title">World Settings</div>
                <div class="control-group">
                    <div class="control-label">Map Size <span class="val-display" id="lbl-mapSize"></span></div>
                    <input type="range" id="in-mapSize" min="100" max="600" step="50">
                </div>
                <div class="control-group">
                    <div class="control-label">Target FPS <span class="val-display" id="lbl-simSpeed"></span></div>
                    <input type="range" id="in-simSpeed" min="1" max="60" step="1">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Initial Density</div>
                <div class="control-group">
                    <div class="control-label">Prey % <span class="val-display" id="lbl-densityPrey"></span></div>
                    <input type="range" id="in-densityPrey" min="0.05" max="1.0" step="0.05">
                </div>
                <div class="control-group">
                    <div class="control-label">Pred % <span class="val-display" id="lbl-densityPred"></span></div>
                    <input type="range" id="in-densityPred" min="0.005" max="0.05" step="0.005">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Prey Stats</div>
                <div class="control-group">
                    <div class="control-label">Metabolism <span class="val-display" id="lbl-preyMetabolism"></span></div>
                    <input type="range" id="in-preyMetabolism" min="0.01" max="0.5" step="0.01">
                </div>
                <div class="control-group">
                    <div class="control-label">Birth Cost <span class="val-display" id="lbl-preyBirthCost"></span></div>
                    <input type="range" id="in-preyBirthCost" min="10" max="150" step="5">
                </div>
                <div class="control-group">
                    <div class="control-label">Food Gain <span class="val-display" id="lbl-preyGainFood"></span></div>
                    <input type="range" id="in-preyGainFood" min="5" max="100" step="5">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Predator Stats</div>
                <div class="control-group">
                    <div class="control-label">Metabolism <span class="val-display" id="lbl-predMetabolism"></span></div>
                    <input type="range" id="in-predMetabolism" min="0.1" max="1.5" step="0.05">
                </div>
                <div class="control-group">
                    <div class="control-label">Birth Cost <span class="val-display" id="lbl-predBirthCost"></span></div>
                    <input type="range" id="in-predBirthCost" min="100" max="400" step="10">
                </div>
                <div class="control-group">
                    <div class="control-label">Hunt Fatigue <span class="val-display" id="lbl-predHuntCost"></span></div>
                    <input type="range" id="in-predHuntCost" min="0" max="10" step="1">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Environment</div>
                <div class="control-group">
                    <div class="control-label">Food Spawn <span class="val-display" id="lbl-foodSpawnRate"></span></div>
                    <input type="range" id="in-foodSpawnRate" min="1" max="100" step="1">
                </div>
            </div>

            <div class="btn-row">
                <button class="action-btn btn-gray" id="btn-pause" onclick="togglePause()">Pause</button>
                <button class="action-btn btn-blue" onclick="restartSim()">Apply & Restart</button>
            </div>
        </div>
    </div>

    <canvas id="simCanvas"></canvas>

<script>
const DEFAULT_CONF = {
    mapSize: 300,
    simSpeed: 30,
    densityPrey: 0.001, densityPred: 0.0001, 
    preyMetabolism: 0.18, preyBirthCost: 90, preyGainFood: 10,       
    predMetabolism: 0.40, predBirthCost: 390, predHuntCost: 5,        
    foodSpawnRate: 20,       
    densityRock: 0.08,
    visionRange: 60,
    preyLife: 600, preyEnergyMax: 120, preyBirthThresh: 0.80,
    predLife: 500, predEnergyMax: 400, predBirthThresh: 0.95,
    predReproCooldown: 300, predGainPrey: 120,
};

let CONF = { ...DEFAULT_CONF };
let VISION_SQ = CONF.visionRange * CONF.visionRange;

const BASE_TILE_SIZE = 5; 
let grid, cols, rows;
let entities = [];
let isPaused = false;

let sectors = [], sCols, sRows; 
let SECTOR_SIZE;

let camera = { x: 0, y: 0, zoom: 1 };
let isDragging = false;
let lastMouse = { x: 0, y: 0 };
let currentTool = 'pan'; // pan, prey, predator, rock, food, erase

let spriteCache = {}; 

let lastTime = 0, frameCount = 0, fpsTimer = 0;
let lastFrameTime = 0; 
let popHistory = [], MAX_HISTORY = 300; 

let canvas, ctx, graphCanvas, graphCtx;

window.onload = () => {
    canvas = document.getElementById('simCanvas');
    ctx = canvas.getContext('2d', { alpha: false });
    graphCanvas = document.getElementById('graphCanvas');
    graphCtx = graphCanvas.getContext('2d');

    generateSprites();
    
    setupUI();
    setupInput();
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); 
    restartSim();   
    loop(0);
};

// --- SPRITE GENERATOR ---
function generateSprites() {
    const types = ['prey', 'predator'];
    const states = ['idle', 'action', 'sleep'];
    
    const drawFace = (ctx, color, type, state) => {
        let size = 64;
        let cx = size/2, cy = size/2;
        
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(cx, cy, 28, 0, Math.PI*2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.arc(cx-10, cy-10, 10, 0, Math.PI*2);
        ctx.fill();

        if(state === 'sleep') {
            ctx.strokeStyle = '#333'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(cx-15, cy); ctx.lineTo(cx-5, cy); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx+5, cy); ctx.lineTo(cx+15, cy); ctx.stroke();
            ctx.fillStyle = '#fff'; ctx.font = 'bold 14px monospace'; ctx.fillText('z', cx+10, cy-15);
        } else {
            ctx.fillStyle = '#fff';
            let eyeSize = (state === 'action' && type === 'prey') ? 10 : 8;
            ctx.beginPath(); ctx.arc(cx-10, cy-5, eyeSize, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(cx+10, cy-5, eyeSize, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = '#000';
            let pSize = 3;
            ctx.beginPath(); ctx.arc(cx-10, cy-5, pSize, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(cx+10, cy-5, pSize, 0, Math.PI*2); ctx.fill();

            if(type === 'predator') {
                ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(cx-18, cy-12); ctx.lineTo(cx-4, cy-8); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx+4, cy-8); ctx.lineTo(cx+18, cy-12); ctx.stroke();
            }
            ctx.beginPath();
            ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
            if(state === 'action' && type === 'prey') {
                ctx.arc(cx, cy+10, 6, 0, Math.PI*2);
                ctx.stroke();
            } else if (type === 'predator') {
                ctx.moveTo(cx-8, cy+12); ctx.lineTo(cx+8, cy+12); ctx.stroke();
            } else {
                ctx.arc(cx, cy+10, 8, 0, Math.PI, false);
                ctx.stroke();
            }
        }
    };

    types.forEach(t => {
        states.forEach(s => {
            let c = document.createElement('canvas');
            c.width = 64; c.height = 64;
            let x = c.getContext('2d');
            let color = t === 'prey' ? '#00ccff' : '#ff2222';
            if(s === 'action') color = t === 'prey' ? '#aaf' : '#ff0000';
            drawFace(x, color, t, s);
            spriteCache[`${t}_${s}`] = c;
        });
    });
}

function setupUI() {
    const bind = (key, isPercentage = false) => {
        const input = document.getElementById('in-' + key);
        const label = document.getElementById('lbl-' + key);
        let val = CONF[key];
        if (isPercentage) val *= 100; 
        input.value = parseFloat(val.toPrecision(6));
        const updateLabel = () => label.innerText = input.value + (isPercentage ? '%' : '');
        updateLabel();
        input.oninput = () => {
            updateLabel();
            let newVal = parseFloat(input.value);
            if (isPercentage) newVal /= 100;
            CONF[key] = newVal;
            if(key === 'visionRange') {
                VISION_SQ = CONF.visionRange * CONF.visionRange;
            }
        };
    };
    bind('mapSize'); bind('simSpeed');
    bind('densityPrey', true); bind('densityPred', true);
    bind('preyMetabolism'); bind('preyBirthCost'); bind('preyGainFood');
    bind('predMetabolism'); bind('predBirthCost'); bind('predHuntCost');
    bind('foodSpawnRate');
}

function setTool(t) {
    currentTool = t;
    canvas.style.cursor = (t === 'pan') ? 'grab' : 'crosshair';
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    let btnId = 'tool-' + (t === 'predator' ? 'pred' : t);
    document.getElementById(btnId).classList.add('active');
}

function setupInput() {
    const getGridPos = (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        // Convert screen to world
        const wx = (mx - camera.x) / camera.zoom;
        const wy = (my - camera.y) / camera.zoom;
        // Convert world to grid
        const gx = Math.floor(wx / BASE_TILE_SIZE);
        const gy = Math.floor(wy / BASE_TILE_SIZE);
        return { x: gx, y: gy };
    }

    const applyTool = (e) => {
        const p = getGridPos(e);
        if(p.x < 0 || p.x >= cols || p.y < 0 || p.y >= rows) return;

        if(currentTool === 'pan') return;

        // Clear existing if painting logic requires
        if(currentTool === 'erase') {
            if(grid.entities[p.x][p.y]) {
                grid.entities[p.x][p.y].dead = true;
                grid.entities[p.x][p.y] = null;
            }
            grid.terrain[p.x][p.y] = null;
            return;
        }

        // Cannot place entity on rock
        if (grid.terrain[p.x][p.y] === 'rock' && (currentTool === 'prey' || currentTool === 'predator' || currentTool === 'food')) {
            return; 
        }

        // Painting Rock or Food
        if(currentTool === 'rock' || currentTool === 'food') {
             if(grid.entities[p.x][p.y]) {
                 grid.entities[p.x][p.y].dead = true; // Kill entity if placing block on top
                 grid.entities[p.x][p.y] = null;
             }
             grid.terrain[p.x][p.y] = currentTool;
             return;
        }

        // Painting Entities
        if(currentTool === 'prey' || currentTool === 'predator') {
            // If cell is empty or occupied by different type, overwrite
            if(!grid.entities[p.x][p.y]) {
                let ent = new Entity(p.x, p.y, currentTool);
                entities.push(ent);
                grid.entities[p.x][p.y] = ent;
            }
        }
    }

    canvas.addEventListener('mousedown', e => { 
        isDragging = true; 
        lastMouse = {x: e.clientX, y: e.clientY}; 
        applyTool(e);
    });

    window.addEventListener('mouseup', () => { 
        isDragging = false; 
        if(currentTool === 'pan') canvas.style.cursor = 'grab';
    });

    window.addEventListener('mousemove', e => {
        if(isDragging) {
            if(currentTool === 'pan') {
                canvas.style.cursor = 'grabbing';
                let dx = e.clientX - lastMouse.x;
                let dy = e.clientY - lastMouse.y;
                camera.x += dx; 
                camera.y += dy;
                lastMouse = {x: e.clientX, y: e.clientY};
            } else {
                applyTool(e);
                // Rate limit painting slightly can be done here if needed, but canvas is fast enough
            }
        }
    });

    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        let zoomFactor = 1.1;
        if (e.deltaY > 0) camera.zoom /= zoomFactor;
        else camera.zoom *= zoomFactor;
        camera.zoom = Math.max(0.5, Math.min(camera.zoom, 20)); 
    }, {passive:false});
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

function togglePanel() { document.getElementById('panel').classList.toggle('open'); }
function togglePause() {
    isPaused = !isPaused;
    document.getElementById('btn-pause').innerText = isPaused ? "Resume" : "Pause";
}

function restartSim() {
    // Apply Map Size
    cols = CONF.mapSize;
    rows = CONF.mapSize;
    
    // Center Camera
    camera.x = -((cols * BASE_TILE_SIZE) - canvas.width) / 2;
    camera.y = -((rows * BASE_TILE_SIZE) - canvas.height) / 2;
    camera.zoom = 1.0;

    SECTOR_SIZE = Math.ceil(CONF.visionRange); 
    sCols = Math.ceil(cols / SECTOR_SIZE);
    sRows = Math.ceil(rows / SECTOR_SIZE);

    grid = {
        terrain: new Array(cols).fill(0).map(() => new Array(rows).fill(null)),
        entities: new Array(cols).fill(0).map(() => new Array(rows).fill(null))
    };
    entities = [];
    popHistory = [];
    
    const total = cols * rows;
    spawnTerrain('rock', total * CONF.densityRock);
    spawnTerrain('food', total * 0.15);
    spawnEntity('prey', Math.max(1, Math.floor(total * CONF.densityPrey)));
    spawnEntity('predator', Math.max(1, Math.floor(total * CONF.densityPred)));
}

function loop(timestamp) {
    requestAnimationFrame(loop);

    const fpsInterval = 1000 / CONF.simSpeed;
    const elapsed = timestamp - lastFrameTime;

    if (!lastTime) lastTime = timestamp;
    const dt = timestamp - lastTime; 
    lastTime = timestamp;
    frameCount++; fpsTimer += dt;
    if (fpsTimer >= 1000) { document.getElementById('dispFps').innerText = frameCount; frameCount = 0; fpsTimer = 0; }

    if (elapsed > fpsInterval) {
        lastFrameTime = timestamp - (elapsed % fpsInterval);
        if(!isPaused) update();
    }
    
    draw();
}

class Entity {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type; 
        this.dead = false; this.age = 0;
        this.maxAge = (type === 'prey') ? CONF.preyLife : CONF.predLife;
        this.energy = (type === 'prey') ? 60 : 250;
        this.maxEnergy = (type === 'prey') ? CONF.preyEnergyMax : CONF.predEnergyMax;
        this.stamina = 100; this.isSleeping = false; this.sleepTimer = 0; this.reproTimer = 0; 
        this.state = 'idle'; 
    }
}

function spawnTerrain(type, count) {
    for(let i=0; i<count; i++) {
        let x = rInt(cols), y = rInt(rows);
        if(!grid.terrain[x][y] && !grid.entities[x][y]) grid.terrain[x][y] = type;
    }
}

function spawnEntity(type, count) {
    let spawned = 0, attempts = 0;
    while(spawned < count && attempts < count * 10) {
        let x = rInt(cols), y = rInt(rows);
        if(grid.terrain[x][y] !== 'rock' && !grid.entities[x][y]) {
            let e = new Entity(x, y, type);
            grid.entities[x][y] = e; entities.push(e); spawned++;
        }
        attempts++;
    }
}

function update() {
    for(let i=0; i<CONF.foodSpawnRate; i++) {
        let x = rInt(cols), y = rInt(rows);
        if(!grid.terrain[x][y] && !grid.entities[x][y]) grid.terrain[x][y] = 'food';
    }

    if(entities.length > 0) {
        let alive = [];
        for(let e of entities) if(!e.dead) alive.push(e);
        entities = alive;
    }

    for (let i = entities.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [entities[i], entities[j]] = [entities[j], entities[i]];
    }
    
    sectors = new Array(sCols * sRows).fill(null).map(()=>[]);
    for(let e of entities) {
        let sx = Math.floor(e.x / SECTOR_SIZE), sy = Math.floor(e.y / SECTOR_SIZE);
        if(sx >= 0 && sx < sCols && sy >= 0 && sy < sRows) sectors[sy * sCols + sx].push(e);
    }

    let cPrey = 0, cPred = 0;
    for (let e of entities) {
        if(e.dead) continue;
        if(e.type === 'prey') cPrey++; else cPred++;
        e.age++;
        e.energy -= (e.type === 'predator') ? CONF.predMetabolism : CONF.preyMetabolism;
        if(e.reproTimer > 0) e.reproTimer--;
        if(e.energy <= 0 || e.age >= e.maxAge) { die(e); continue; }
        if(e.isSleeping) {
            e.stamina += 5; e.sleepTimer--;
            if(e.sleepTimer <= 0 && e.stamina >= 100) { e.isSleeping = false; e.stamina = 100; }
            continue;
        }
        if(e.stamina <= 0) { e.isSleeping = true; continue; }
        runAI(e);
    }

    document.getElementById('dispPrey').innerText = cPrey;
    document.getElementById('dispPred').innerText = cPred;
    updateGraph(cPrey, cPred);
}

function runAI(e) {
    let nearest = getNearestNeighbor(e); 
    if(e.type === 'prey') {
        if(nearest.pred) {
            e.state = 'action'; 
            move(e, getBestMove(e, nearest.pred.x, nearest.pred.y, true));
            e.stamina -= 2;
        } else {
            e.state = 'idle';
            let nearbyFood = scanTerrain(e, 12, 'food');
            if(nearbyFood && e.energy < e.maxEnergy * 0.9) {
                move(e, getBestMove(e, nearbyFood.x, nearbyFood.y, false));
            } else {
                if(Math.random() < 0.25) move(e, getRandomMove(e));
                else e.stamina = Math.min(100, e.stamina + 2);
            }
        }
        if(e.energy > e.maxEnergy * CONF.preyBirthThresh) reproduce(e);
    } else {
        if(nearest.prey) {
            e.state = 'action';
            let target = nearest.prey;
            move(e, getBestMove(e, target.x, target.y, false));
            if(e.stamina > 15) {
                 move(e, getBestMove(e, target.x, target.y, false));
                 e.stamina -= CONF.predHuntCost;
            }
        } else {
            e.state = 'idle';
            if(Math.random() < 0.5) move(e, getRandomMove(e));
            else e.stamina = Math.min(100, e.stamina + 3);
        }
        if(e.reproTimer === 0 && e.energy > e.maxEnergy * CONF.predBirthThresh) reproduce(e);
    }
}

function getNearestNeighbor(e) {
    let closestPred = null, closestPrey = null;
    let minDistPred = VISION_SQ, minDistPrey = VISION_SQ;
    let sx = Math.floor(e.x / SECTOR_SIZE), sy = Math.floor(e.y / SECTOR_SIZE);

    for(let dy = -1; dy <= 1; dy++) {
        for(let dx = -1; dx <= 1; dx++) {
            let nsx = (sx + dx + sCols) % sCols;
            let nsy = (sy + dy + sRows) % sRows;
            let sector = sectors[nsy * sCols + nsx];
            if(!sector) continue;
            for(let other of sector) {
                if(other === e || other.dead) continue;
                let diffX = Math.abs(e.x - other.x);
                let diffY = Math.abs(e.y - other.y);
                if(diffX > cols/2) diffX = cols - diffX;
                if(diffY > rows/2) diffY = rows - diffY;
                let dSq = diffX*diffX + diffY*diffY;
                if(dSq <= VISION_SQ) {
                    if(other.type === 'predator') {
                        if(dSq < minDistPred) { minDistPred = dSq; closestPred = other; }
                    } else {
                        if(dSq < minDistPrey) { minDistPrey = dSq; closestPrey = other; }
                    }
                }
            }
        }
    }
    return { pred: closestPred, prey: closestPrey };
}

function scanTerrain(e, range, type) {
    let best = null, minD = range * range + 1; 
    for(let dx = -range; dx <= range; dx++) {
        for(let dy = -range; dy <= range; dy++) {
            let nx = (e.x+dx+cols)%cols, ny = (e.y+dy+rows)%rows;
            if(grid.terrain[nx][ny] === type) {
                let dSq = dx*dx + dy*dy;
                if(dSq < minD) { minD = dSq; best = {x:nx, y:ny}; }
            }
        }
    }
    return best;
}

const MOVES = [{x:0,y:-1},{x:1,y:-1},{x:1,y:0},{x:1,y:1},{x:0,y:1},{x:-1,y:1},{x:-1,y:0},{x:-1,y:-1}];
const SIMPLE_MOVES = [{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];

function getBestMove(e, tx, ty, flee) {
    let best = null, score = flee ? -1 : Infinity;
    let idxs = [0,1,2,3,4,5,6,7];
    for (let i = idxs.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [idxs[i], idxs[j]] = [idxs[j], idxs[i]];
    }
    for(let i of idxs) {
        let m = MOVES[i];
        let nx=(e.x+m.x+cols)%cols, ny=(e.y+m.y+rows)%rows;
        if(grid.terrain[nx][ny] === 'rock') continue;
        let occ = grid.entities[nx][ny];
        if(occ && occ.type === e.type) continue; 
        let dx = Math.abs(nx - tx), dy = Math.abs(ny - ty);
        if(dx > cols/2) dx = cols-dx;
        if(dy > rows/2) dy = rows-dy;
        let dSq = dx*dx + dy*dy;
        if(flee) { if(dSq > score) { score = dSq; best = {x:nx, y:ny}; } }
        else { if(dSq < score) { score = dSq; best = {x:nx, y:ny}; } }
    }
    return best;
}

function getRandomMove(e) {
    let idxs = [0,1,2,3];
    for (let i = idxs.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [idxs[i], idxs[j]] = [idxs[j], idxs[i]];
    }
    for(let i of idxs) {
        let m = SIMPLE_MOVES[i];
        let nx=(e.x+m.x+cols)%cols, ny=(e.y+m.y+rows)%rows;
        if(grid.terrain[nx][ny]!=='rock' && !grid.entities[nx][ny]) return {x:nx,y:ny};
    }
    return null;
}

function move(e, dest) {
    if(!dest) return;
    let tEnt = grid.entities[dest.x][dest.y];
    let tTerr = grid.terrain[dest.x][dest.y];
    if(e.type === 'predator' && tEnt && tEnt.type === 'prey') {
        e.energy = Math.min(e.maxEnergy, e.energy + CONF.predGainPrey);
        e.isSleeping = true; e.sleepTimer = 20; 
        die(tEnt); updatePos(e, dest.x, dest.y);
    } 
    else if(e.type === 'prey' && tTerr === 'food') {
        e.energy = Math.min(e.maxEnergy, e.energy + CONF.preyGainFood);
        grid.terrain[dest.x][dest.y] = null; updatePos(e, dest.x, dest.y);
    }
    else if(!tEnt) updatePos(e, dest.x, dest.y);
}

function updatePos(e, nx, ny) {
    grid.entities[e.x][e.y] = null; e.x = nx; e.y = ny; grid.entities[nx][ny] = e;
}

function reproduce(e) {
    let idxs = [0,1,2,3,4,5,6,7];
    for (let i = idxs.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [idxs[i], idxs[j]] = [idxs[j], idxs[i]];
    }
    for(let i of idxs) {
        let m = MOVES[i];
        let nx=(e.x+m.x+cols)%cols, ny=(e.y+m.y+rows)%rows;
        if(!grid.entities[nx][ny] && grid.terrain[nx][ny]!=='rock') {
             let cost = (e.type === 'predator') ? CONF.predBirthCost : CONF.preyBirthCost;
             if(e.energy > cost) {
                let baby = new Entity(nx, ny, e.type);
                e.energy -= cost;
                if(e.type === 'predator') e.reproTimer = CONF.predReproCooldown;
                grid.entities[nx][ny] = baby;
                entities.push(baby);
             }
             return;
        }
    }
}

function die(e) { e.dead = true; if(grid.entities[e.x][e.y] === e) grid.entities[e.x][e.y] = null; }
function rInt(n) { return Math.floor(Math.random()*n); }

// --- RENDERING ---

function draw() {
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(camera.x, camera.y);
    ctx.scale(camera.zoom, camera.zoom);

    let startCol = Math.floor(-camera.x / (BASE_TILE_SIZE * camera.zoom));
    let startRow = Math.floor(-camera.y / (BASE_TILE_SIZE * camera.zoom));
    let viewCols = Math.ceil(canvas.width / (BASE_TILE_SIZE * camera.zoom));
    let viewRows = Math.ceil(canvas.height / (BASE_TILE_SIZE * camera.zoom));

    let pad = 2; 
    let minX = startCol - pad;
    let maxX = startCol + viewCols + pad;
    let minY = startRow - pad;
    let maxY = startRow + viewRows + pad;
    
    minX = Math.max(0, minX);
    maxX = Math.min(cols, maxX);
    minY = Math.max(0, minY);
    maxY = Math.min(rows, maxY);

    let drawSize = BASE_TILE_SIZE;
    let useSprites = (drawSize * camera.zoom) > 12;

    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, cols * BASE_TILE_SIZE, rows * BASE_TILE_SIZE);

    for(let x = minX; x < maxX; x++) {
        for(let y = minY; y < maxY; y++) {
            let t = grid.terrain[x][y];
            let px = x * BASE_TILE_SIZE;
            let py = y * BASE_TILE_SIZE;

            if(t === 'rock') {
                ctx.fillStyle = '#222'; ctx.fillRect(px, py, drawSize, drawSize);
                ctx.fillStyle = '#333'; ctx.fillRect(px+1, py+1, drawSize-2, drawSize-2);
            } else if (t === 'food') {
                ctx.fillStyle = '#004400'; ctx.beginPath();
                ctx.arc(px+drawSize/2, py+drawSize/2, drawSize/3, 0, Math.PI*2); ctx.fill();
            }

            let e = grid.entities[x][y];
            if(e) {
                if(useSprites) {
                    let state = 'idle';
                    if(e.isSleeping) state = 'sleep';
                    else if(e.state === 'action') state = 'action';
                    let spriteKey = `${e.type}_${state}`;
                    let img = spriteCache[spriteKey];
                    if(img) ctx.drawImage(img, px, py, drawSize, drawSize);
                } else {
                    if(e.type==='prey') ctx.fillStyle = (e.state==='action') ? '#fff' : '#00ccff';
                    else ctx.fillStyle = (e.state==='action') ? '#ff0000' : '#550000';
                    ctx.fillRect(px, py, drawSize, drawSize);
                    if(e.isSleeping) {
                        ctx.fillStyle = '#ff0'; ctx.fillRect(px+drawSize/4, py+drawSize/4, drawSize/2, drawSize/2);
                    }
                }
            }
        }
    }
    
    ctx.strokeStyle = '#444'; ctx.lineWidth = 2;
    ctx.strokeRect(0,0, cols*BASE_TILE_SIZE, rows*BASE_TILE_SIZE);

    // Draw highlight for tool cursor
    if(currentTool !== 'pan') {
       // This is a bit complex because mouse is in screen coords, need to reverse project
       // We can use lastMouse but it only updates on move
    }

    ctx.restore();
}

function updateGraph(preyCount, predCount) {
    popHistory.push({ p: preyCount, r: predCount });
    if(popHistory.length > MAX_HISTORY) popHistory.shift();
    const w = graphCanvas.width, h = graphCanvas.height;
    graphCtx.clearRect(0, 0, w, h);
    let maxVal = 10;
    for(let d of popHistory) maxVal = Math.max(maxVal, d.p, d.r);
    const getY = (val) => h - ((val / maxVal) * (h - 10)) - 5; 
    const getX = (i) => (i / (MAX_HISTORY-1)) * w;
    if(popHistory.length < 2) return;

    const drawLine = (prop, color) => {
        graphCtx.beginPath(); graphCtx.strokeStyle = color; graphCtx.lineWidth = 2;
        graphCtx.moveTo(0, getY(popHistory[0][prop]));
        for(let i=1; i<popHistory.length; i++) graphCtx.lineTo(getX(i), getY(popHistory[i][prop]));
        graphCtx.stroke();
    };
    drawLine('p', '#00ccff'); drawLine('r', '#ff2222');
}
</script>
</body>
</html>