<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EcoSim V15 - Logic Restored</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Segoe UI', Roboto, monospace; color: #ccc; }
        canvas { display: block; }
        
        /* HUD & UI STYLES (Same as before) */
        #hud { position: absolute; top: 15px; left: 15px; background: rgba(10, 10, 10, 0.8); border: 1px solid #333; border-radius: 6px; padding: 10px 15px; pointer-events: none; user-select: none; display: flex; flex-direction: column; gap: 5px; font-family: 'Courier New', monospace; font-weight: bold; z-index: 50; box-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        .hud-row { display: flex; justify-content: space-between; min-width: 180px; }
        .hud-label { display: flex; align-items: center; gap: 8px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
        .dot-prey { background: #00ccff; box-shadow: 0 0 5px #00ccff; }
        .dot-pred { background: #ff2222; box-shadow: 0 0 5px #ff2222; }
        .hud-fps { font-size: 0.8rem; color: #666; margin-top: 5px; border-top: 1px solid #333; padding-top: 5px;}
        #graph-container { position: absolute; bottom: 15px; left: 15px; width: 300px; height: 100px; background: rgba(10, 10, 10, 0.8); border: 1px solid #333; border-radius: 6px; z-index: 40; pointer-events: none; }
        #graphCanvas { width: 100%; height: 100%; display: block; border-radius: 6px; }
        #controls-btn { position: absolute; top: 15px; right: 15px; padding: 8px 16px; background: #333; border: 1px solid #555; color: #fff; cursor: pointer; border-radius: 4px; z-index: 60; font-size: 0.8rem; text-transform: uppercase; }
        #controls-btn:hover { background: #444; }
        #panel { position: absolute; top: 0; right: 0; width: 300px; height: 100vh; background: rgba(12, 12, 12, 0.98); border-left: 1px solid #333; display: flex; flex-direction: column; box-shadow: -5px 0 20px rgba(0,0,0,0.8); transition: transform 0.3s ease; transform: translateX(100%); overflow-y: auto; z-index: 55; }
        #panel.open { transform: translateX(0); }
        .header { padding: 15px; background: #181818; border-bottom: 1px solid #333; }
        .header h2 { margin: 0; font-size: 0.9rem; color: #eee; text-transform: uppercase; }
        .content { padding: 15px; padding-bottom: 50px; }
        .section { margin-bottom: 20px; border-bottom: 1px solid #222; padding-bottom: 10px; }
        .section-title { font-size: 0.7rem; color: #666; text-transform: uppercase; margin-bottom: 10px; font-weight: bold; }
        .control-group { margin-bottom: 10px; }
        .control-label { display: flex; justify-content: space-between; font-size: 0.8rem; margin-bottom: 3px; color: #bbb; }
        .val-display { color: #00ccff; font-family: monospace; }
        input[type=range] { width: 100%; height: 4px; background: #333; border-radius: 2px; appearance: none; cursor: pointer; }
        input[type=range]::-webkit-slider-thumb { appearance: none; width: 14px; height: 14px; background: #00ccff; border-radius: 50%; cursor: pointer; border: 1px solid #000; }
        .btn-row { display: flex; gap: 10px; margin-top: 20px; }
        button.action-btn { flex: 1; padding: 10px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 0.8rem; text-transform: uppercase; color: #fff; }
        .btn-blue { background: #0055aa; } .btn-blue:hover { background: #0066cc; }
        .btn-gray { background: #333; } .btn-gray:hover { background: #444; }
    </style>
</head>
<body>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-row">
            <div class="hud-label"><span class="dot dot-prey"></span> Prey</div>
            <span id="dispPrey">0</span>
        </div>
        <div class="hud-row">
            <div class="hud-label"><span class="dot dot-pred"></span> Preds</div>
            <span id="dispPred">0</span>
        </div>
        <div class="hud-fps">
            FPS: <span id="dispFps" style="color:#fff">0</span>
        </div>
    </div>

    <!-- GRAPH -->
    <div id="graph-container">
        <canvas id="graphCanvas" width="300" height="100"></canvas>
    </div>

    <!-- CONTROLS -->
    <button id="controls-btn" onclick="togglePanel()">Settings</button>
    <div id="panel">
        <div class="header"><h2>Parameters</h2></div>
        <div class="content">
            <!-- Settings Inputs (IDs match script) -->
            <div class="section"><div class="section-title">Initial Density</div><div class="control-group"><div class="control-label">Prey % <span class="val-display" id="lbl-densityPrey"></span></div><input type="range" id="in-densityPrey" min="0.05" max="1.0" step="0.05"></div><div class="control-group"><div class="control-label">Pred % <span class="val-display" id="lbl-densityPred"></span></div><input type="range" id="in-densityPred" min="0.005" max="0.05" step="0.005"></div></div>
            <div class="section"><div class="section-title">Prey Stats</div><div class="control-group"><div class="control-label">Metabolism <span class="val-display" id="lbl-preyMetabolism"></span></div><input type="range" id="in-preyMetabolism" min="0.01" max="0.5" step="0.01"></div><div class="control-group"><div class="control-label">Birth Cost <span class="val-display" id="lbl-preyBirthCost"></span></div><input type="range" id="in-preyBirthCost" min="10" max="150" step="5"></div><div class="control-group"><div class="control-label">Food Energy <span class="val-display" id="lbl-preyGainFood"></span></div><input type="range" id="in-preyGainFood" min="5" max="100" step="5"></div></div>
            <div class="section"><div class="section-title">Predator Stats</div><div class="control-group"><div class="control-label">Metabolism <span class="val-display" id="lbl-predMetabolism"></span></div><input type="range" id="in-predMetabolism" min="0.1" max="1.5" step="0.05"></div><div class="control-group"><div class="control-label">Birth Cost <span class="val-display" id="lbl-predBirthCost"></span></div><input type="range" id="in-predBirthCost" min="100" max="400" step="10"></div><div class="control-group"><div class="control-label">Hunt Fatigue <span class="val-display" id="lbl-predHuntCost"></span></div><input type="range" id="in-predHuntCost" min="0" max="10" step="1"></div></div>
            <div class="section"><div class="section-title">Environment</div><div class="control-group"><div class="control-label">Food Spawn <span class="val-display" id="lbl-foodSpawnRate"></span></div><input type="range" id="in-foodSpawnRate" min="1" max="50" step="1"></div></div>
            <div class="btn-row"><button class="action-btn btn-gray" id="btn-pause" onclick="togglePause()">Pause</button><button class="action-btn btn-blue" onclick="restartSim()">Apply & Reset</button></div>
        </div>
    </div>

    <canvas id="simCanvas"></canvas>

<script>
const DEFAULT_CONF = {
    densityPrey: 0.001, densityPred: 0.0001, 
    preyMetabolism: 0.18, preyBirthCost: 90, preyGainFood: 10,       
    predMetabolism: 0.40, predBirthCost: 390, predHuntCost: 5,        
    foodSpawnRate: 9,       
    densityRock: 0.08,
    visionRange: 60,
    preyLife: 600, preyEnergyMax: 120, preyBirthThresh: 0.80,
    predLife: 500, predEnergyMax: 400, predBirthThresh: 0.95,
    predReproCooldown: 300, predGainPrey: 120
};

let CONF = { ...DEFAULT_CONF };
let VISION_SQ = CONF.visionRange * CONF.visionRange;

const GRID_SIZE = 5; 
const COLORS = {
    bg: '#020202', rock: '#1a1a1a', food: '#003300', 
    prey: '#00ccff', preyPanic: '#ffffff', 
    predStalk: '#550000', predHunt: '#ff0000', sleep: '#ffff00'
};

let canvas, ctx, graphCanvas, graphCtx, bgCanvas, bgCtx;
let grid, cols, rows;
let entities = [];
let isPaused = false;

// --- OPTIMIZATION VARS ---
// Fix 1: Sector Size must equal Vision Range to ensure full visibility
// If Vision is 60 and sector is 60, checking neighbors covers -60 to +60, which is safe.
let sectors = [];
let sCols, sRows;
let SECTOR_SIZE; // Will be set to visionRange

// FPS & Graph
let lastTime = 0, frameCount = 0, fpsTimer = 0;
let popHistory = [], MAX_HISTORY = 300; 

window.onload = () => {
    canvas = document.getElementById('simCanvas');
    ctx = canvas.getContext('2d', { alpha: false });
    graphCanvas = document.getElementById('graphCanvas');
    graphCtx = graphCanvas.getContext('2d');
    bgCanvas = document.createElement('canvas');
    bgCtx = bgCanvas.getContext('2d');

    setupUI();
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); 
    loop(0);
};

function setupUI() {
    const bind = (key, isPercentage = false) => {
        const input = document.getElementById('in-' + key);
        const label = document.getElementById('lbl-' + key);
        let val = CONF[key];
        if (isPercentage) val *= 100; 
        input.value = parseFloat(val.toPrecision(6));
        const updateLabel = () => label.innerText = input.value + (isPercentage ? '%' : '');
        updateLabel();
        input.oninput = () => {
            updateLabel();
            let newVal = parseFloat(input.value);
            if (isPercentage) newVal /= 100;
            CONF[key] = newVal;
            if(key === 'visionRange') VISION_SQ = CONF.visionRange * CONF.visionRange;
        };
    };
    bind('densityPrey', true); bind('densityPred', true);
    bind('preyMetabolism'); bind('preyBirthCost'); bind('preyGainFood');
    bind('predMetabolism'); bind('predBirthCost'); bind('predHuntCost');
    bind('foodSpawnRate');
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    bgCanvas.width = canvas.width;
    bgCanvas.height = canvas.height;
    restartSim();
}

function togglePanel() { document.getElementById('panel').classList.toggle('open'); }
function togglePause() {
    isPaused = !isPaused;
    document.getElementById('btn-pause').innerText = isPaused ? "Resume" : "Pause";
}

function restartSim() {
    cols = Math.ceil(canvas.width / GRID_SIZE);
    rows = Math.ceil(canvas.height / GRID_SIZE);
    
    // OPTIMIZATION: Set Sector Size to Vision Range (in grid units)
    SECTOR_SIZE = Math.ceil(CONF.visionRange); 
    sCols = Math.ceil(cols / SECTOR_SIZE);
    sRows = Math.ceil(rows / SECTOR_SIZE);

    grid = {
        terrain: new Array(cols).fill(0).map(() => new Array(rows).fill(null)),
        entities: new Array(cols).fill(0).map(() => new Array(rows).fill(null))
    };
    entities = [];
    popHistory = [];
    
    const total = cols * rows;
    spawnTerrain('rock', total * CONF.densityRock);
    spawnTerrain('food', total * 0.15);
    spawnEntity('prey', Math.max(1, Math.floor(total * CONF.densityPrey)));
    spawnEntity('predator', Math.max(1, Math.floor(total * CONF.densityPred)));
    
    drawStaticBackground();
}

function updateGraph(preyCount, predCount) {
    popHistory.push({ p: preyCount, r: predCount });
    if(popHistory.length > MAX_HISTORY) popHistory.shift();
    const w = graphCanvas.width, h = graphCanvas.height;
    graphCtx.clearRect(0, 0, w, h);
    let maxVal = 10;
    for(let d of popHistory) { maxVal = Math.max(maxVal, d.p, d.r); }
    const getY = (val) => h - ((val / maxVal) * (h - 10)) - 5; 
    const getX = (i) => (i / (MAX_HISTORY-1)) * w;
    if(popHistory.length < 2) return;

    const drawLine = (prop, color) => {
        graphCtx.beginPath(); graphCtx.strokeStyle = color; graphCtx.lineWidth = 2;
        graphCtx.moveTo(0, getY(popHistory[0][prop]));
        for(let i=1; i<popHistory.length; i++) graphCtx.lineTo(getX(i), getY(popHistory[i][prop]));
        graphCtx.stroke();
    };
    drawLine('p', '#00ccff'); drawLine('r', '#ff2222');
}

// --- CORE SIMULATION ---

class Entity {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type; 
        this.dead = false; this.age = 0;
        this.maxAge = (type === 'prey') ? CONF.preyLife : CONF.predLife;
        this.energy = (type === 'prey') ? 60 : 250;
        this.maxEnergy = (type === 'prey') ? CONF.preyEnergyMax : CONF.predEnergyMax;
        this.stamina = 100; this.isSleeping = false; this.sleepTimer = 0; this.reproTimer = 0; 
        this.state = 'idle'; 
    }
}

function spawnTerrain(type, count) {
    for(let i=0; i<count; i++) {
        let x = rInt(cols), y = rInt(rows);
        if(!grid.terrain[x][y] && !grid.entities[x][y]) grid.terrain[x][y] = type;
    }
}

function spawnEntity(type, count) {
    let spawned = 0, attempts = 0;
    while(spawned < count && attempts < count * 10) {
        let x = rInt(cols), y = rInt(rows);
        if(grid.terrain[x][y] !== 'rock' && !grid.entities[x][y]) {
            let e = new Entity(x, y, type);
            grid.entities[x][y] = e; entities.push(e); spawned++;
        }
        attempts++;
    }
}

function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = timestamp - lastTime; lastTime = timestamp;
    frameCount++; fpsTimer += dt;
    if (fpsTimer >= 1000) { document.getElementById('dispFps').innerText = frameCount; frameCount = 0; fpsTimer = 0; }
    
    if(!isPaused) update();
    draw();
    requestAnimationFrame(loop);
}

function update() {
    for(let i=0; i<CONF.foodSpawnRate; i++) {
        let x = rInt(cols), y = rInt(rows);
        if(!grid.terrain[x][y] && !grid.entities[x][y]) grid.terrain[x][y] = 'food';
    }

    // Filter dead (faster than splice in loop)
    if(entities.length > 0) {
        let alive = [];
        for(let e of entities) if(!e.dead) alive.push(e);
        entities = alive;
    }
    
    // OPTIMIZATION: Rebuild Spatial Grid (Sectors)
    sectors = new Array(sCols * sRows).fill(null).map(()=>[]);
    for(let e of entities) {
        let sx = Math.floor(e.x / SECTOR_SIZE), sy = Math.floor(e.y / SECTOR_SIZE);
        if(sx >= 0 && sx < sCols && sy >= 0 && sy < sRows) sectors[sy * sCols + sx].push(e);
    }

    let cPrey = 0, cPred = 0;
    
    // Entities "Think"
    for (let e of entities) {
        if(e.dead) continue;
        if(e.type === 'prey') cPrey++; else cPred++;

        e.age++;
        e.energy -= (e.type === 'predator') ? CONF.predMetabolism : CONF.preyMetabolism;
        if(e.reproTimer > 0) e.reproTimer--;

        if(e.energy <= 0 || e.age >= e.maxAge) { die(e); continue; }

        if(e.isSleeping) {
            e.stamina += 5; e.sleepTimer--;
            if(e.sleepTimer <= 0 && e.stamina >= 100) { e.isSleeping = false; e.stamina = 100; }
            continue;
        }
        if(e.stamina <= 0) { e.isSleeping = true; continue; }

        runAI(e);
    }

    document.getElementById('dispPrey').innerText = cPrey;
    document.getElementById('dispPred').innerText = cPred;
    updateGraph(cPrey, cPred);
}

function runAI(e) {
    let nearest = getNearestNeighbor(e); 
    
    if(e.type === 'prey') {
        if(nearest.pred) {
            e.state = 'flee';
            move(e, getBestMove(e, nearest.pred.x, nearest.pred.y, true));
            e.stamina -= 2;
        } else {
            e.state = 'idle';
            let nearbyFood = scanTerrain(e, 12, 'food');
            if(nearbyFood && e.energy < e.maxEnergy * 0.9) {
                move(e, getBestMove(e, nearbyFood.x, nearbyFood.y, false));
            } else {
                if(Math.random() < 0.25) move(e, getRandomMove(e));
                else e.stamina = Math.min(100, e.stamina + 2);
            }
        }
        if(e.energy > e.maxEnergy * CONF.preyBirthThresh) reproduce(e);
    } else {
        if(nearest.prey) {
            e.state = 'hunt';
            let target = nearest.prey;
            move(e, getBestMove(e, target.x, target.y, false));
            if(e.stamina > 15) {
                 move(e, getBestMove(e, target.x, target.y, false));
                 e.stamina -= CONF.predHuntCost;
            }
        } else {
            e.state = 'stalk';
            if(Math.random() < 0.5) move(e, getRandomMove(e));
            else e.stamina = Math.min(100, e.stamina + 3);
        }
        if(e.reproTimer === 0 && e.energy > e.maxEnergy * CONF.predBirthThresh) reproduce(e);
    }
}

// --- LOGIC HELPERS ---

// FIXED: Handles Wrap-Around logic correctly and ensures Vision Range isn't clipped
function getNearestNeighbor(e) {
    let closestPred = null, closestPrey = null;
    let minDistPred = VISION_SQ, minDistPrey = VISION_SQ;

    let sx = Math.floor(e.x / SECTOR_SIZE);
    let sy = Math.floor(e.y / SECTOR_SIZE);

    // Check 3x3 sectors with Wrap-Around (Torus topology)
    for(let dy = -1; dy <= 1; dy++) {
        for(let dx = -1; dx <= 1; dx++) {
            // Fix 2: Wrap indices correctly
            let nsx = (sx + dx + sCols) % sCols;
            let nsy = (sy + dy + sRows) % sRows;
            
            let sector = sectors[nsy * sCols + nsx];
            // Safety check if grid resized weirdly
            if(!sector) continue; 

            for(let other of sector) {
                if(other === e || other.dead) continue;

                let diffX = Math.abs(e.x - other.x);
                let diffY = Math.abs(e.y - other.y);
                // Fix 3: Distance calculation must respect grid wrapping
                if(diffX > cols/2) diffX = cols - diffX;
                if(diffY > rows/2) diffY = rows - diffY;
                
                let dSq = diffX*diffX + diffY*diffY;

                if(dSq <= VISION_SQ) {
                    if(other.type === 'predator') {
                        if(dSq < minDistPred) { minDistPred = dSq; closestPred = other; }
                    } else {
                        if(dSq < minDistPrey) { minDistPrey = dSq; closestPrey = other; }
                    }
                }
            }
        }
    }
    return { pred: closestPred, prey: closestPrey };
}

function scanTerrain(e, range, type) {
    let best = null, minD = range * range + 1; 
    for(let dx = -range; dx <= range; dx++) {
        for(let dy = -range; dy <= range; dy++) {
            let nx = (e.x+dx+cols)%cols;
            let ny = (e.y+dy+rows)%rows;
            if(grid.terrain[nx][ny] === type) {
                let dSq = dx*dx + dy*dy;
                if(dSq < minD) { minD = dSq; best = {x:nx, y:ny}; }
            }
        }
    }
    return best;
}

const MOVES = [
    {x:0,y:-1},{x:1,y:-1},{x:1,y:0},{x:1,y:1},
    {x:0,y:1},{x:-1,y:1},{x:-1,y:0},{x:-1,y:-1}
];

function getBestMove(e, tx, ty, flee) {
    let best = null;
    let score = flee ? -1 : Infinity;

    // Fix 4: Restore Fisher-Yates Shuffle for true randomness
    // The previous optimization used a rotating index which biased movement
    let idxs = [0,1,2,3,4,5,6,7];
    for (let i = idxs.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [idxs[i], idxs[j]] = [idxs[j], idxs[i]];
    }

    for(let i of idxs) {
        let m = MOVES[i];
        let nx=(e.x+m.x+cols)%cols, ny=(e.y+m.y+rows)%rows;
        
        if(grid.terrain[nx][ny] === 'rock') continue;
        let occ = grid.entities[nx][ny];
        if(occ && occ.type === e.type) continue; 
        
        let dx = Math.abs(nx - tx), dy = Math.abs(ny - ty);
        if(dx > cols/2) dx = cols-dx;
        if(dy > rows/2) dy = rows-dy;
        let dSq = dx*dx + dy*dy;

        if(flee) { 
            if(dSq > score) { score = dSq; best = {x:nx, y:ny}; } 
        } else { 
            if(dSq < score) { score = dSq; best = {x:nx, y:ny}; } 
        }
    }
    return best;
}

const SIMPLE_MOVES = [{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];
function getRandomMove(e) {
    // Restore randomness here too
    let idxs = [0,1,2,3];
    for (let i = idxs.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [idxs[i], idxs[j]] = [idxs[j], idxs[i]];
    }
    for(let i of idxs) {
        let m = SIMPLE_MOVES[i];
        let nx=(e.x+m.x+cols)%cols, ny=(e.y+m.y+rows)%rows;
        if(grid.terrain[nx][ny]!=='rock' && !grid.entities[nx][ny]) return {x:nx,y:ny};
    }
    return null;
}

function move(e, dest) {
    if(!dest) return;
    let tEnt = grid.entities[dest.x][dest.y];
    let tTerr = grid.terrain[dest.x][dest.y];
    
    if(e.type === 'predator' && tEnt && tEnt.type === 'prey') {
        e.energy = Math.min(e.maxEnergy, e.energy + CONF.predGainPrey);
        e.isSleeping = true; e.sleepTimer = 20; 
        die(tEnt);
        updatePos(e, dest.x, dest.y);
    } 
    else if(e.type === 'prey' && tTerr === 'food') {
        e.energy = Math.min(e.maxEnergy, e.energy + CONF.preyGainFood);
        grid.terrain[dest.x][dest.y] = null;
        updatePos(e, dest.x, dest.y);
    }
    else if(!tEnt) {
        updatePos(e, dest.x, dest.y);
    }
}

function updatePos(e, nx, ny) {
    grid.entities[e.x][e.y] = null;
    e.x = nx; e.y = ny;
    grid.entities[nx][ny] = e;
}

function reproduce(e) {
    // Restore randomness for birth spots
    let idxs = [0,1,2,3,4,5,6,7];
    for (let i = idxs.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [idxs[i], idxs[j]] = [idxs[j], idxs[i]];
    }
    for(let i of idxs) {
        let m = MOVES[i];
        let nx=(e.x+m.x+cols)%cols, ny=(e.y+m.y+rows)%rows;
        if(!grid.entities[nx][ny] && grid.terrain[nx][ny]!=='rock') {
             let cost = (e.type === 'predator') ? CONF.predBirthCost : CONF.preyBirthCost;
             if(e.energy > cost) {
                let baby = new Entity(nx, ny, e.type);
                e.energy -= cost;
                if(e.type === 'predator') e.reproTimer = CONF.predReproCooldown;
                grid.entities[nx][ny] = baby;
                entities.push(baby);
             }
             return;
        }
    }
}

function die(e) {
    e.dead = true;
    if(grid.entities[e.x][e.y] === e) grid.entities[e.x][e.y] = null;
}

function rInt(n) { return Math.floor(Math.random()*n); }

function drawStaticBackground() {
    bgCtx.fillStyle = COLORS.bg;
    bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
    bgCtx.fillStyle = COLORS.rock;
    for(let x=0; x<cols; x++) {
        for(let y=0; y<rows; y++) {
            if(grid.terrain[x][y] === 'rock') bgCtx.fillRect(x*GRID_SIZE, y*GRID_SIZE, GRID_SIZE, GRID_SIZE); 
        }
    }
}

function draw() {
    ctx.drawImage(bgCanvas, 0, 0);
    ctx.fillStyle = COLORS.food;
    for(let x=0; x<cols; x++) {
        for(let y=0; y<rows; y++) {
            if(grid.terrain[x][y] === 'food') ctx.fillRect(x*GRID_SIZE, y*GRID_SIZE, GRID_SIZE, GRID_SIZE);
        }
    }
    for(let e of entities) {
        if(e.dead) continue;
        let px=e.x*GRID_SIZE, py=e.y*GRID_SIZE;
        if(e.type==='prey') ctx.fillStyle = (e.state==='flee') ? COLORS.preyPanic : COLORS.prey;
        else ctx.fillStyle = (e.state==='hunt') ? COLORS.predHunt : COLORS.predStalk;
        
        ctx.fillRect(px, py, GRID_SIZE, GRID_SIZE); 
        if(e.isSleeping) {
            ctx.fillStyle = COLORS.sleep; ctx.fillRect(px+1, py+1, GRID_SIZE-2, GRID_SIZE-2);
        }
    }
}
</script>
</body>
</html>