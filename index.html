<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EcoSim HD</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Roboto, monospace; color: #ccc; touch-action: none; }
        /* Canvas scales based on CSS, but renders based on internal resolution */
        canvas { display: block; touch-action: none; width: 100%; height: 100%; }
        
        /* HUD */
        #hud { position: absolute; top: 15px; left: 15px; background: rgba(10, 10, 10, 0.85); border: 1px solid #333; border-radius: 6px; padding: 10px 15px; pointer-events: none; user-select: none; display: flex; flex-direction: column; gap: 5px; font-family: 'Courier New', monospace; font-weight: bold; z-index: 50; box-shadow: 0 4px 12px rgba(0,0,0,0.5); backdrop-filter: blur(4px); }
        .hud-row { display: flex; justify-content: space-between; min-width: 180px; }
        .hud-label { display: flex; align-items: center; gap: 8px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
        .dot-prey { background: #00ccff; box-shadow: 0 0 5px #00ccff; }
        .dot-pred { background: #ff2222; box-shadow: 0 0 5px #ff2222; }
        .hud-fps { font-size: 0.8rem; color: #666; margin-top: 5px; border-top: 1px solid #333; padding-top: 5px;}

        /* GRAPH */
        #graph-container { position: absolute; bottom: 80px; left: 15px; width: 200px; height: 60px; background: rgba(10, 10, 10, 0.8); border: 1px solid #333; border-radius: 6px; z-index: 40; pointer-events: none; opacity: 0.9; }
        #graphCanvas { width: 100%; height: 100%; display: block; border-radius: 6px; }

        /* TOOLBAR */
        #toolbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(25, 25, 25, 0.95); border: 1px solid #444; border-radius: 8px;
            display: flex; gap: 5px; padding: 6px; z-index: 60;
            box-shadow: 0 6px 20px rgba(0,0,0,0.6);
            white-space: nowrap;
            backdrop-filter: blur(5px);
        }
        .tool-btn {
            width: 44px; height: 44px; border: 1px solid #444; background: #333;
            border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 1.3rem; color: #fff; transition: all 0.1s ease-out; flex-shrink: 0;
        }
        .tool-btn:active { transform: scale(0.95); }
        .tool-btn.active { background: #0066cc; border-color: #4499ff; box-shadow: 0 0 10px #0055aa; transform: scale(1.05); z-index: 1; }

        /* CONTROLS */
        #controls-btn { position: absolute; top: 15px; right: 15px; padding: 8px 16px; background: #333; border: 1px solid #555; color: #fff; cursor: pointer; border-radius: 4px; z-index: 60; font-size: 0.8rem; text-transform: uppercase; font-weight: 600; }
        #panel { position: absolute; top: 0; right: 0; width: 320px; height: 100vh; background: rgba(15, 15, 15, 0.98); border-left: 1px solid #333; display: flex; flex-direction: column; box-shadow: -5px 0 25px rgba(0,0,0,0.9); transition: transform 0.3s cubic-bezier(0.2, 1, 0.3, 1); transform: translateX(100%); overflow-y: auto; z-index: 70; }
        #panel.open { transform: translateX(0); }
        .header { padding: 18px; background: #202020; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center;}
        .header h2 { margin: 0; font-size: 1rem; color: #fff; letter-spacing: 1px; text-transform: uppercase; }
        .close-btn { background: none; border: none; color: #888; font-size: 1.8rem; cursor: pointer; line-height: 1; }
        .content { padding: 20px; padding-bottom: 60px; }
        .section { margin-bottom: 25px; border-bottom: 1px solid #2a2a2a; padding-bottom: 15px; }
        .section-title { font-size: 0.75rem; color: #888; text-transform: uppercase; margin-bottom: 12px; font-weight: bold; letter-spacing: 0.5px; }
        .control-group { margin-bottom: 12px; }
        .control-label { display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 5px; color: #ccc; }
        .val-display { color: #00ccff; font-family: monospace; }
        
        input[type=range] { width: 100%; height: 5px; background: #444; border-radius: 3px; appearance: none; cursor: pointer; outline: none; }
        input[type=range]::-webkit-slider-thumb { appearance: none; width: 16px; height: 16px; background: #00ccff; border-radius: 50%; cursor: pointer; border: 2px solid #111; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        
        .btn-row { display: flex; gap: 10px; margin-top: 20px; }
        button.action-btn { flex: 1; padding: 12px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 0.85rem; text-transform: uppercase; color: #fff; transition: background 0.2s; }
        .btn-blue { background: #0066cc; } .btn-blue:hover { background: #0077dd; }
        .btn-gray { background: #444; } .btn-gray:hover { background: #555; }

        @media (max-width: 768px) {
            #toolbar { width: 95%; bottom: 15px; overflow-x: auto; justify-content: flex-start; -webkit-overflow-scrolling: touch; padding-bottom: 10px; }
            .tool-btn { width: 52px; height: 52px; font-size: 1.5rem; }
            #panel { width: 100%; }
            #hud { font-size: 0.8rem; padding: 8px; top: 10px; left: 10px; }
            #graph-container { display: none; }
        }
    </style>
</head>
<body>

    <div id="hud">
        <div class="hud-row"><div class="hud-label"><span class="dot dot-prey"></span> Prey</div><span id="dispPrey">0</span></div>
        <div class="hud-row"><div class="hud-label"><span class="dot dot-pred"></span> Preds</div><span id="dispPred">0</span></div>
        <div class="hud-fps">FPS: <span id="dispFps" style="color:#fff">0</span></div>
    </div>

    <div id="graph-container"><canvas id="graphCanvas" width="200" height="60"></canvas></div>

    <div id="toolbar">
        <div class="tool-btn active" id="tool-pan" onclick="setTool('pan')" title="Pan Camera">✋</div>
        <div class="tool-btn" id="tool-prey" onclick="setTool('prey')" title="Add Prey" style="color:#00ccff">●</div>
        <div class="tool-btn" id="tool-pred" onclick="setTool('predator')" title="Add Predator" style="color:#ff2222">●</div>
        <div class="tool-btn" id="tool-rock" onclick="setTool('rock')" title="Add Rock">⬛</div>
        <div class="tool-btn" id="tool-food" onclick="setTool('food')" title="Add Food" style="color:#00aa00">♣</div>
        <div class="tool-btn" id="tool-erase" onclick="setTool('erase')" title="Eraser">✖</div>
    </div>

    <button id="controls-btn" onclick="togglePanel()">Settings</button>

    <div id="panel">
        <div class="header"><h2>Parameters</h2><button class="close-btn" onclick="togglePanel()">×</button></div>
        <div class="content">
            <div class="section">
                <div class="section-title">World Settings</div>
                <div class="control-group"><div class="control-label">Map Size <span class="val-display" id="lbl-mapSize"></span></div><input type="range" id="in-mapSize" min="100" max="600" step="50"></div>
                <div class="control-group"><div class="control-label">Target FPS <span class="val-display" id="lbl-simSpeed"></span></div><input type="range" id="in-simSpeed" min="1" max="60" step="1"></div>
            </div>
            <div class="section">
                <div class="section-title">Initial Density</div>
                <div class="control-group"><div class="control-label">Prey % <span class="val-display" id="lbl-densityPrey"></span></div><input type="range" id="in-densityPrey" min="0.05" max="1.0" step="0.05"></div>
                <div class="control-group"><div class="control-label">Pred % <span class="val-display" id="lbl-densityPred"></span></div><input type="range" id="in-densityPred" min="0.005" max="0.05" step="0.005"></div>
            </div>
            <div class="section">
                <div class="section-title">Prey Stats</div>
                <div class="control-group"><div class="control-label">Metabolism <span class="val-display" id="lbl-preyMetabolism"></span></div><input type="range" id="in-preyMetabolism" min="0.01" max="0.5" step="0.01"></div>
                <div class="control-group"><div class="control-label">Birth Cost <span class="val-display" id="lbl-preyBirthCost"></span></div><input type="range" id="in-preyBirthCost" min="10" max="150" step="5"></div>
                <div class="control-group"><div class="control-label">Food Gain <span class="val-display" id="lbl-preyGainFood"></span></div><input type="range" id="in-preyGainFood" min="5" max="100" step="5"></div>
            </div>
            <div class="section">
                <div class="section-title">Predator Stats</div>
                <div class="control-group"><div class="control-label">Metabolism <span class="val-display" id="lbl-predMetabolism"></span></div><input type="range" id="in-predMetabolism" min="0.1" max="1.5" step="0.05"></div>
                <div class="control-group"><div class="control-label">Birth Cost <span class="val-display" id="lbl-predBirthCost"></span></div><input type="range" id="in-predBirthCost" min="100" max="400" step="10"></div>
                <div class="control-group"><div class="control-label">Hunt Fatigue <span class="val-display" id="lbl-predHuntCost"></span></div><input type="range" id="in-predHuntCost" min="0" max="10" step="1"></div>
            </div>
            <div class="section">
                <div class="section-title">Environment</div>
                <div class="control-group"><div class="control-label">Food Spawn <span class="val-display" id="lbl-foodSpawnRate"></span></div><input type="range" id="in-foodSpawnRate" min="1" max="100" step="1"></div>
            </div>
            <div class="btn-row"><button class="action-btn btn-gray" id="btn-pause" onclick="togglePause()">Pause</button><button class="action-btn btn-blue" onclick="restartSim()">Apply & Restart</button></div>
        </div>
    </div>

    <canvas id="simCanvas"></canvas>

<script>
// --- WEBGL SHADERS (Pass 1: Sprites) ---
const VS_SOURCE = `#version 300 es
layout(location=0) in vec2 a_pos;      
layout(location=1) in vec4 a_instance; // x, y, size, typeIndex
uniform mat3 u_matrix;                 
uniform vec2 u_atlasSize;              
out vec2 v_texCoord;
void main() {
    // Expand vertex to world pos
    vec2 worldPos = a_instance.xy + (a_pos * a_instance.z);
    vec3 finalPos = u_matrix * vec3(worldPos, 1.0);
    gl_Position = vec4(finalPos.xy, 0.0, 1.0);
    
    // Map texture coordinates from Atlas
    float spriteIdx = a_instance.w;
    float spriteSize = 64.0;
    float u = (spriteIdx * spriteSize + a_pos.x * spriteSize) / u_atlasSize.x;
    float v = (a_pos.y * spriteSize) / u_atlasSize.y;
    v_texCoord = vec2(u, v);
}`;

const FS_SOURCE = `#version 300 es
precision mediump float;
in vec2 v_texCoord;
uniform sampler2D u_texture;
out vec4 outColor;
void main() {
    vec4 color = texture(u_texture, v_texCoord);
    // Smooth alpha blending instead of discard for nicer edges
    outColor = color;
}`;

const DEFAULT_CONF = {
    mapSize: 300, simSpeed: 30,
    densityPrey: 0.001, densityPred: 0.0001, 
    preyMetabolism: 0.18, preyBirthCost: 90, preyGainFood: 10,       
    predMetabolism: 0.40, predBirthCost: 390, predHuntCost: 5,        
    foodSpawnRate: 20, densityRock: 0.08, visionRange: 60,
    preyLife: 600, preyEnergyMax: 120, preyBirthThresh: 0.80,
    predLife: 500, predEnergyMax: 400, predBirthThresh: 0.95,
    predReproCooldown: 300, predGainPrey: 120,
};

let CONF = { ...DEFAULT_CONF };
let VISION_SQ = CONF.visionRange * CONF.visionRange;
const BASE_TILE_SIZE = 5; 
let grid, cols, rows, entities = [], isPaused = false;
let sectors = [], sCols, sRows, SECTOR_SIZE;
let camera = { x: 0, y: 0, zoom: 1 };
let isDragging = false, lastMouse = { x: 0, y: 0 }, currentTool = 'pan'; 
let lastTouchDist = 0, isPinching = false, lastPinchCenter = {x:0, y:0};
let lastTime = 0, frameCount = 0, fpsTimer = 0, lastFrameTime = 0; 
let popHistory = [], MAX_HISTORY = 300; 
let canvas, gl, graphCanvas, graphCtx;
let glState = {};
let dpr = 1;

// Sprite IDs
const SID = { ROCK:0, FOOD:1, PREY:2, PREY_ACT:3, PREY_SLP:4, PRED:5, PRED_ACT:6, PRED_SLP:7 };

window.onload = () => {
    canvas = document.getElementById('simCanvas');
    // Request AA and Alpha for smooth edges
    gl = canvas.getContext('webgl2', { alpha: true, antialias: true, premultipliedAlpha: false });
    if(!gl) { alert("WebGL2 not supported"); return; }
    
    graphCanvas = document.getElementById('graphCanvas');
    graphCtx = graphCanvas.getContext('2d');

    setupWebGL();
    setupUI();
    setupInput();
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); 
    restartSim();   
    loop(0);
};

function resizeCanvas() {
    // High DPI support
    dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    gl.viewport(0, 0, canvas.width, canvas.height);
}

// --- WEBGL SETUP ---
function setupWebGL() {
    // Enable Blending for smooth edges (Antialiasing inside textures)
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    const createShader = (type, src) => {
        const s = gl.createShader(type);
        gl.shaderSource(s, src); gl.compileShader(s);
        if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
        return s;
    };
    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl.VERTEX_SHADER, VS_SOURCE));
    gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, FS_SOURCE));
    gl.linkProgram(program);
    gl.useProgram(program);
    glState.program = program;

    // Generate Texture Atlas
    const atlasCanvas = document.createElement('canvas');
    const spriteSize = 64;
    const count = 8; 
    atlasCanvas.width = spriteSize * count;
    atlasCanvas.height = spriteSize;
    const ctx = atlasCanvas.getContext('2d');
    
    const drawFace = (dx, color, type, state) => {
        let cx = dx + 32, cy = 32;
        // Clear background for alpha
        ctx.clearRect(dx, 0, 64, 64);
        
        if(type === 'rock') { 
            ctx.fillStyle = '#222'; ctx.fillRect(dx,0,64,64); 
            ctx.fillStyle = '#333'; ctx.fillRect(dx+2,2,60,60); return; 
        }
        if(type === 'food') {
            // Glow
            ctx.shadowBlur = 10; ctx.shadowColor = '#00ff00';
            ctx.fillStyle = '#00aa00'; ctx.beginPath(); ctx.arc(cx,cy,24,0,Math.PI*2); ctx.fill(); 
            ctx.shadowBlur = 0; return;
        }
        
        // Smooth Entities
        ctx.shadowBlur = 5; ctx.shadowColor = color;
        ctx.beginPath(); ctx.fillStyle = color; ctx.arc(cx, cy, 28, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        
        // Reflection
        ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.arc(cx-10, cy-10, 10, 0, Math.PI*2); ctx.fill();
        
        if(state === 'sleep') {
            ctx.strokeStyle='#333'; ctx.lineWidth=3; ctx.lineCap='round';
            ctx.beginPath(); ctx.moveTo(cx-15,cy); ctx.lineTo(cx-5,cy); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx+5,cy); ctx.lineTo(cx+15,cy); ctx.stroke();
            ctx.fillStyle='#fff'; ctx.font='bold 16px monospace'; ctx.fillText('z', cx+10, cy-15);
        } else {
            ctx.fillStyle='#fff'; 
            let es = (state === 'action' && type === 'prey') ? 11 : 9;
            ctx.beginPath(); ctx.arc(cx-10, cy-5, es, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(cx+10, cy-5, es, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle='#000'; 
            ctx.beginPath(); ctx.arc(cx-10, cy-5, 4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(cx+10, cy-5, 4, 0, Math.PI*2); ctx.fill();
            
            ctx.beginPath(); ctx.strokeStyle='#000'; ctx.lineWidth=2.5; ctx.lineCap='round';
            if(type==='predator') {
                ctx.moveTo(cx-18,cy-12); ctx.lineTo(cx-4,cy-8); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx+4,cy-8); ctx.lineTo(cx+18,cy-12); ctx.stroke();
            }
            ctx.beginPath();
            if(state==='action' && type==='prey') { ctx.arc(cx,cy+12,6,0,Math.PI*2); ctx.stroke(); }
            else if(type==='predator') { ctx.moveTo(cx-10,cy+14); ctx.lineTo(cx+10,cy+14); ctx.stroke(); }
            else { ctx.arc(cx,cy+12,8,0,Math.PI,false); ctx.stroke(); }
        }
    };
    drawFace(0, null, 'rock');
    drawFace(64, null, 'food');
    drawFace(128, '#00ccff', 'prey', 'idle');
    drawFace(192, '#aaaaff', 'prey', 'action');
    drawFace(256, '#00ccff', 'prey', 'sleep');
    drawFace(320, '#ff2222', 'predator', 'idle');
    drawFace(384, '#ff5555', 'predator', 'action');
    drawFace(448, '#ff2222', 'predator', 'sleep');

    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, atlasCanvas);
    
    // TRILINEAR FILTERING for smooth zoom
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    
    gl.uniform1i(gl.getUniformLocation(program, 'u_texture'), 0);
    gl.uniform2f(gl.getUniformLocation(program, 'u_atlasSize'), atlasCanvas.width, atlasCanvas.height);

    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    const posBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,0, 1,1, 0,1]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

    const instanceBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
    // Large buffer for 100k entities
    gl.bufferData(gl.ARRAY_BUFFER, 100000 * 16, gl.DYNAMIC_DRAW); 
    gl.enableVertexAttribArray(1);
    gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 16, 0); 
    gl.vertexAttribDivisor(1, 1); 

    glState.vao = vao;
    glState.instanceBuffer = instanceBuffer;
    glState.instanceData = new Float32Array(100000 * 4);
    glState.locMatrix = gl.getUniformLocation(program, 'u_matrix');
}

// --- INPUT & UI ---
function setupInput() {
    const getGridPos = (cx, cy) => {
        const rect = canvas.getBoundingClientRect(); // Physical coords
        // Adjust for zoom and pan
        const mx = cx - rect.left, my = cy - rect.top;
        const wx = (mx - camera.x) / camera.zoom, wy = (my - camera.y) / camera.zoom;
        return { x: Math.floor(wx / BASE_TILE_SIZE), y: Math.floor(wy / BASE_TILE_SIZE) };
    }
    const applyTool = (cx, cy) => {
        const p = getGridPos(cx, cy);
        if(p.x < 0 || p.x >= cols || p.y < 0 || p.y >= rows) return;
        if(currentTool === 'pan') return;
        if(currentTool === 'erase') {
            if(grid.entities[p.x][p.y]) { grid.entities[p.x][p.y].dead = true; grid.entities[p.x][p.y] = null; }
            grid.terrain[p.x][p.y] = null; return;
        }
        if (grid.terrain[p.x][p.y] === 'rock' && (currentTool === 'prey' || currentTool === 'predator' || currentTool === 'food')) return; 
        if(currentTool === 'rock' || currentTool === 'food') {
             if(grid.entities[p.x][p.y]) { grid.entities[p.x][p.y].dead = true; grid.entities[p.x][p.y] = null; }
             grid.terrain[p.x][p.y] = currentTool; return;
        }
        if((currentTool === 'prey' || currentTool === 'predator') && !grid.entities[p.x][p.y]) {
            let ent = new Entity(p.x, p.y, currentTool); entities.push(ent); grid.entities[p.x][p.y] = ent;
        }
    }
    canvas.addEventListener('mousedown', e => { isDragging = true; lastMouse = {x: e.clientX, y: e.clientY}; applyTool(e.clientX, e.clientY); });
    window.addEventListener('mouseup', () => { isDragging = false; if(currentTool === 'pan') canvas.style.cursor = 'grab'; });
    window.addEventListener('mousemove', e => {
        if(isDragging) {
            if(currentTool === 'pan') {
                canvas.style.cursor = 'grabbing';
                camera.x += e.clientX - lastMouse.x; camera.y += e.clientY - lastMouse.y;
                lastMouse = {x: e.clientX, y: e.clientY};
            } else applyTool(e.clientX, e.clientY);
        }
    });
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        let newZoom = Math.max(0.1, Math.min(camera.zoom * (e.deltaY > 0 ? 0.9 : 1.1), 20));
        let scaleChange = newZoom / camera.zoom;
        camera.x = mx - (mx - camera.x) * scaleChange; camera.y = my - (my - camera.y) * scaleChange;
        camera.zoom = newZoom;
    }, {passive:false});

    const getTouchDist = (e) => Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    const getTouchCenter = (e) => e.touches.length >= 2 ? {x: (e.touches[0].clientX+e.touches[1].clientX)/2, y: (e.touches[0].clientY+e.touches[1].clientY)/2} : {x:0,y:0};

    canvas.addEventListener('touchstart', e => {
        if(e.target !== canvas) return; e.preventDefault();
        if(e.touches.length === 1) { isDragging = true; isPinching = false; lastMouse = {x: e.touches[0].clientX, y: e.touches[0].clientY}; if(currentTool !== 'pan') applyTool(lastMouse.x, lastMouse.y); }
        else if (e.touches.length === 2) { isPinching = true; isDragging = false; lastTouchDist = getTouchDist(e); lastPinchCenter = getTouchCenter(e); }
    }, {passive: false});
    canvas.addEventListener('touchmove', e => {
        if(e.target !== canvas) return; e.preventDefault();
        if(isPinching && e.touches.length === 2) {
            let dist = getTouchDist(e), center = getTouchCenter(e);
            let newZoom = Math.max(0.1, Math.min(camera.zoom * (dist / lastTouchDist), 20));
            let effectiveChange = newZoom / camera.zoom; camera.zoom = newZoom;
            camera.x = center.x - (lastPinchCenter.x - camera.x) * effectiveChange;
            camera.y = center.y - (lastPinchCenter.y - camera.y) * effectiveChange;
            lastTouchDist = dist; lastPinchCenter = center;
        } else if (isDragging && e.touches.length === 1) {
            let tx = e.touches[0].clientX, ty = e.touches[0].clientY;
            if(currentTool === 'pan') { camera.x += tx - lastMouse.x; camera.y += ty - lastMouse.y; } else applyTool(tx, ty);
            lastMouse = {x: tx, y: ty};
        }
    }, {passive: false});
    canvas.addEventListener('touchend', e => { e.preventDefault(); if(e.touches.length < 2) isPinching = false; if(e.touches.length === 0) isDragging = false; if(e.touches.length === 1) { lastMouse = {x: e.touches[0].clientX, y: e.touches[0].clientY}; isDragging = true; }});
}

function setupUI() {
    const bind = (k, p=false) => {
        const i = document.getElementById('in-'+k), l = document.getElementById('lbl-'+k);
        const up = () => l.innerText = i.value + (p?'%':'');
        i.value = parseFloat((CONF[k]*(p?100:1)).toPrecision(6)); up();
        i.oninput = () => { up(); CONF[k] = parseFloat(i.value)/(p?100:1); if(k==='visionRange') VISION_SQ=CONF[k]**2; };
    };
    bind('mapSize'); bind('simSpeed'); bind('densityPrey',1); bind('densityPred',1);
    bind('preyMetabolism'); bind('preyBirthCost'); bind('preyGainFood');
    bind('predMetabolism'); bind('predBirthCost'); bind('predHuntCost'); bind('foodSpawnRate');
}
function setTool(t) {
    currentTool = t; canvas.style.cursor = (t === 'pan') ? 'grab' : 'crosshair';
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('tool-' + (t === 'predator' ? 'pred' : t)).classList.add('active');
}
function togglePanel() { document.getElementById('panel').classList.toggle('open'); }
function togglePause() { isPaused = !isPaused; document.getElementById('btn-pause').innerText = isPaused ? "Resume" : "Pause"; }

// --- SIMULATION CORE ---
function restartSim() {
    cols = CONF.mapSize; rows = CONF.mapSize;
    let worldW = cols * BASE_TILE_SIZE;
    let worldH = rows * BASE_TILE_SIZE;
    // Use logical pixels for calculations
    let logicW = canvas.width / dpr;
    if(window.innerWidth < 768) {
        let targetZoom = (logicW * 0.95) / worldW;
        camera.zoom = Math.max(0.2, Math.min(targetZoom, 3.0));
    } else camera.zoom = 1.0;
    camera.x = (logicW - worldW * camera.zoom) / 2;
    camera.y = (canvas.height/dpr - worldH * camera.zoom) / 2;
    
    SECTOR_SIZE = Math.ceil(CONF.visionRange); 
    sCols = Math.ceil(cols / SECTOR_SIZE); sRows = Math.ceil(rows / SECTOR_SIZE);
    grid = { terrain: new Array(cols).fill(0).map(()=>new Array(rows).fill(null)), entities: new Array(cols).fill(0).map(()=>new Array(rows).fill(null)) };
    entities = []; popHistory = [];
    const total = cols * rows;
    spawnTerrain('rock', total * CONF.densityRock); spawnTerrain('food', total * 0.15);
    spawnEntity('prey', Math.max(1, Math.floor(total * CONF.densityPrey)));
    spawnEntity('predator', Math.max(1, Math.floor(total * CONF.densityPred)));
}

function loop(ts) {
    requestAnimationFrame(loop);
    if (!lastTime) { lastTime = ts; return; }
    const dt = ts - lastTime; lastTime = ts;
    fpsTimer += dt;
    if (fpsTimer >= 1000) { document.getElementById('dispFps').innerText = frameCount; frameCount = 0; fpsTimer -= 1000; }

    const fpsInterval = 1000 / CONF.simSpeed;
    const elapsed = ts - lastFrameTime;
    const interacting = isDragging || isPinching;

    if (elapsed > fpsInterval || interacting) {
        if (elapsed > fpsInterval) { lastFrameTime = ts - (elapsed % fpsInterval); if(!isPaused) update(); }
        draw(); frameCount++;
    }
}

class Entity {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type; this.dead = false; this.age = 0;
        this.maxAge = (type === 'prey') ? CONF.preyLife : CONF.predLife;
        this.energy = (type === 'prey') ? 60 : 250;
        this.maxEnergy = (type === 'prey') ? CONF.preyEnergyMax : CONF.predEnergyMax;
        this.stamina = 100; this.isSleeping = false; this.sleepTimer = 0; this.reproTimer = 0; this.state = 'idle'; 
    }
}
function spawnTerrain(t, c) { for(let i=0; i<c; i++) { let x=rInt(cols),y=rInt(rows); if(!grid.terrain[x][y] && !grid.entities[x][y]) grid.terrain[x][y] = t; } }
function spawnEntity(t, c) { 
    let s=0, a=0; while(s<c && a<c*10) { let x=rInt(cols),y=rInt(rows); 
    if(grid.terrain[x][y] !== 'rock' && !grid.entities[x][y]) { let e=new Entity(x,y,t); grid.entities[x][y]=e; entities.push(e); s++; } a++; } 
}
function die(e) { e.dead = true; if(grid.entities[e.x][e.y] === e) grid.entities[e.x][e.y] = null; }
function rInt(n) { return Math.floor(Math.random()*n); }

function update() {
    for(let i=0; i<CONF.foodSpawnRate; i++) { let x=rInt(cols),y=rInt(rows); if(!grid.terrain[x][y]&&!grid.entities[x][y]) grid.terrain[x][y]='food'; }
    let alive = []; for(let e of entities) if(!e.dead) alive.push(e); entities = alive;
    for (let i=entities.length-1; i>0; i--) { const j=Math.floor(Math.random()*(i+1)); [entities[i], entities[j]]=[entities[j], entities[i]]; }
    
    sectors = new Array(sCols * sRows).fill(null).map(()=>[]);
    for(let e of entities) { let sx=Math.floor(e.x/SECTOR_SIZE), sy=Math.floor(e.y/SECTOR_SIZE); if(sx>=0 && sx<sCols && sy>=0 && sy<sRows) sectors[sy*sCols+sx].push(e); }
    let cPrey = 0, cPred = 0;
    for (let e of entities) {
        if(e.dead) continue; e.type === 'prey' ? cPrey++ : cPred++; e.age++;
        e.energy -= (e.type === 'predator') ? CONF.predMetabolism : CONF.preyMetabolism;
        if(e.reproTimer > 0) e.reproTimer--;
        if(e.energy <= 0 || e.age >= e.maxAge) { die(e); continue; }
        if(e.isSleeping) { e.stamina += 5; e.sleepTimer--; if(e.sleepTimer <= 0 && e.stamina >= 100) e.isSleeping = false; continue; }
        if(e.stamina <= 0) { e.isSleeping = true; continue; }
        runAI(e);
    }
    document.getElementById('dispPrey').innerText = cPrey; document.getElementById('dispPred').innerText = cPred;
    updateGraph(cPrey, cPred);
}
function runAI(e) {
    let n = getNearestNeighbor(e);
    if(e.type === 'prey') {
        if(n.pred) { e.state = 'action'; move(e, getBestMove(e, n.pred.x, n.pred.y, true)); e.stamina -= 2; } 
        else { e.state = 'idle'; let f = scanTerrain(e, 12, 'food'); 
            if(f && e.energy < e.maxEnergy * 0.9) move(e, getBestMove(e, f.x, f.y, false)); 
            else if(Math.random() < 0.25) move(e, getRandomMove(e)); else e.stamina = Math.min(100, e.stamina+2); 
        }
        if(e.energy > e.maxEnergy * CONF.preyBirthThresh) reproduce(e);
    } else {
        if(n.prey) { e.state = 'action'; let t = n.prey; move(e, getBestMove(e, t.x, t.y, false)); if(e.stamina > 15) { move(e, getBestMove(e, t.x, t.y, false)); e.stamina -= CONF.predHuntCost; } } 
        else { e.state = 'idle'; if(Math.random() < 0.5) move(e, getRandomMove(e)); else e.stamina = Math.min(100, e.stamina+3); }
        if(e.reproTimer === 0 && e.energy > e.maxEnergy * CONF.predBirthThresh) reproduce(e);
    }
}
function getNearestNeighbor(e) {
    let cp=null, cy=null, mdp=VISION_SQ, mdy=VISION_SQ;
    let sx = Math.floor(e.x/SECTOR_SIZE), sy = Math.floor(e.y/SECTOR_SIZE);
    for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++) {
        let nsx=(sx+dx+sCols)%sCols, nsy=(sy+dy+sRows)%sRows;
        let sec = sectors[nsy*sCols+nsx]; if(!sec) continue;
        for(let o of sec) {
            if(o===e || o.dead) continue;
            let dfx=Math.abs(e.x-o.x), dfy=Math.abs(e.y-o.y);
            if(dfx>cols/2) dfx=cols-dfx; if(dfy>rows/2) dfy=rows-dfy;
            let dSq=dfx*dfx+dfy*dfy;
            if(dSq<=VISION_SQ) {
                if(o.type==='predator') { if(dSq<mdp) { mdp=dSq; cp=o; } } 
                else { if(dSq<mdy) { mdy=dSq; cy=o; } }
            }
        }
    }
    return { pred: cp, prey: cy };
}
function scanTerrain(e, r, t) {
    let b=null, md=r*r+1; for(let dx=-r; dx<=r; dx++) for(let dy=-r; dy<=r; dy++) {
        let nx=(e.x+dx+cols)%cols, ny=(e.y+dy+rows)%rows;
        if(grid.terrain[nx][ny]===t) { let dSq=dx*dx+dy*dy; if(dSq<md) { md=dSq; b={x:nx, y:ny}; } }
    } return b;
}
const MOVES = [{x:0,y:-1},{x:1,y:-1},{x:1,y:0},{x:1,y:1},{x:0,y:1},{x:-1,y:1},{x:-1,y:0},{x:-1,y:-1}];
function getBestMove(e, tx, ty, flee) {
    let b=null, sc=flee?-1:Infinity, idx=[0,1,2,3,4,5,6,7];
    for (let i=7; i>0; i--) { const j=Math.floor(Math.random()*(i+1)); [idx[i], idx[j]]=[idx[j], idx[i]]; }
    for(let i of idx) {
        let m=MOVES[i], nx=(e.x+m.x+cols)%cols, ny=(e.y+m.y+rows)%rows;
        if(grid.terrain[nx][ny]==='rock') continue;
        let occ=grid.entities[nx][ny]; if(occ && occ.type===e.type) continue;
        let dx=Math.abs(nx-tx), dy=Math.abs(ny-ty); if(dx>cols/2) dx=cols-dx; if(dy>rows/2) dy=rows-dy;
        let dSq=dx*dx+dy*dy;
        if(flee) { if(dSq>sc) { sc=dSq; b={x:nx,y:ny}; } } else { if(dSq<sc) { sc=dSq; b={x:nx,y:ny}; } }
    } return b;
}
function getRandomMove(e) {
    let idx=[0,2,4,6]; for (let i=3; i>0; i--) { const j=Math.floor(Math.random()*(i+1)); [idx[i], idx[j]]=[idx[j], idx[i]]; }
    for(let i of idx) { let m=MOVES[i], nx=(e.x+m.x+cols)%cols, ny=(e.y+m.y+rows)%rows; if(grid.terrain[nx][ny]!=='rock' && !grid.entities[nx][ny]) return {x:nx,y:ny}; } return null;
}
function move(e, d) {
    if(!d) return; let te=grid.entities[d.x][d.y], tt=grid.terrain[d.x][d.y];
    if(e.type==='predator' && te && te.type==='prey') { e.energy=Math.min(e.maxEnergy, e.energy+CONF.predGainPrey); e.isSleeping=true; e.sleepTimer=20; die(te); upPos(e,d.x,d.y); }
    else if(e.type==='prey' && tt==='food') { e.energy=Math.min(e.maxEnergy, e.energy+CONF.preyGainFood); grid.terrain[d.x][d.y]=null; upPos(e,d.x,d.y); }
    else if(!te) upPos(e,d.x,d.y);
}
function upPos(e,nx,ny) { grid.entities[e.x][e.y]=null; e.x=nx; e.y=ny; grid.entities[nx][ny]=e; }
function reproduce(e) {
    let idx=[0,1,2,3,4,5,6,7]; for (let i=7; i>0; i--) { const j=Math.floor(Math.random()*(i+1)); [idx[i], idx[j]]=[idx[j], idx[i]]; }
    for(let i of idx) {
        let m=MOVES[i], nx=(e.x+m.x+cols)%cols, ny=(e.y+m.y+rows)%rows;
        if(!grid.entities[nx][ny] && grid.terrain[nx][ny]!=='rock') {
             let c = (e.type==='predator') ? CONF.predBirthCost : CONF.preyBirthCost;
             if(e.energy > c) { let b=new Entity(nx,ny,e.type); e.energy-=c; if(e.type==='predator') e.reproTimer=CONF.predReproCooldown; grid.entities[nx][ny]=b; entities.push(b); } return;
        }
    }
}

function updateGraph(prey, pred) {
    popHistory.push({ p: prey, r: pred }); if(popHistory.length > MAX_HISTORY) popHistory.shift();
    // Increase internal res of graph for HD look
    const w = 200 * dpr, h = 60 * dpr;
    if(graphCanvas.width !== w) { graphCanvas.width=w; graphCanvas.height=h; }
    graphCtx.clearRect(0, 0, w, h);
    let maxVal = 10; for(let d of popHistory) maxVal = Math.max(maxVal, d.p, d.r);
    const getY = (val) => h - ((val / maxVal) * (h - 20)) - 10, getX = (i) => (i / (MAX_HISTORY-1)) * w;
    if(popHistory.length < 2) return;
    const drawLine = (prop, color) => {
        graphCtx.beginPath(); graphCtx.strokeStyle = color; graphCtx.lineWidth = 2 * dpr;
        graphCtx.moveTo(0, getY(popHistory[0][prop]));
        for(let i=1; i<popHistory.length; i++) graphCtx.lineTo(getX(i), getY(popHistory[i][prop])); graphCtx.stroke();
    };
    drawLine('p', '#00ccff'); drawLine('r', '#ff2222');
}

// --- WEBGL RENDERER ---
function draw() {
    gl.clearColor(0.02, 0.02, 0.02, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Projection matrix adjusted for DPI
    const w = canvas.width, h = canvas.height; // Physical pixels
    const z = camera.zoom * dpr; // Scale zoom by DPI for consistent view size
    const tx = camera.x, ty = camera.y;
    
    // Standard 2D ortho projection
    const mat = [
        (2 * z) / w, 0, 0,
        0, -(2 * z) / h, 0,
        (2 * (tx * z)) / w - 1, -(2 * (ty * z)) / h + 1, 1 
    ];
    // Fix translation: (WorldPos * Zoom + Camera) -> NDC
    // Actually, the shader does: worldPos = instance + vertex.
    // final = matrix * worldPos.
    // We need matrix to do: (worldPos * zoom * dpr + camera * zoom * dpr) -> NDC
    // My matrix above effectively does: X * (2z/w) + (2tx/w - 1)
    // = (X*z + tx) * 2/w - 1. This assumes tx is already scaled by z? 
    // No, camera.x is in World Units (pixels). 
    // Correct transform: ScreenX = (WorldX + CameraX) * Zoom * DPR.
    // NDC_X = (ScreenX / W) * 2 - 1.
    // = ((WorldX + CameraX) * Zoom * DPR / W) * 2 - 1.
    // = WorldX * (2*Zoom*DPR/W) + (CameraX * 2*Zoom*DPR/W - 1).
    
    // Let's recalculate mat array indices
    const scaleX = (2 * z) / w;
    const scaleY = -(2 * z) / h;
    const transX = (tx * 2 * z) / w - 1;
    const transY = -(ty * 2 * z) / h + 1;

    gl.uniformMatrix3fv(glState.locMatrix, false, [
        scaleX, 0, 0,
        0, scaleY, 0,
        transX, transY, 1
    ]);

    let iData = glState.instanceData;
    let count = 0;
    
    // Culling
    // Visible World Area: 
    // Left = -CameraX, Right = Width/Zoom - CameraX
    let logicW = w / z; 
    let logicH = h / z;
    
    let startCol = Math.floor(-tx / BASE_TILE_SIZE);
    let startRow = Math.floor(-ty / BASE_TILE_SIZE);
    let viewCols = Math.ceil(logicW / BASE_TILE_SIZE);
    let viewRows = Math.ceil(logicH / BASE_TILE_SIZE);
    
    let pad = 2;
    let minX = Math.max(0, startCol - pad), maxX = Math.min(cols, startCol + viewCols + pad);
    let minY = Math.max(0, startRow - pad), maxY = Math.min(rows, startRow + viewRows + pad);
    
    let drawSize = BASE_TILE_SIZE; 
    const push = (x,y,type) => {
        let idx = count * 4;
        iData[idx] = x * BASE_TILE_SIZE;
        iData[idx+1] = y * BASE_TILE_SIZE;
        iData[idx+2] = drawSize;
        iData[idx+3] = type;
        count++;
    };

    for(let x = minX; x < maxX; x++) {
        for(let y = minY; y < maxY; y++) {
            let t = grid.terrain[x][y];
            if(t === 'rock') push(x,y, SID.ROCK);
            else if (t === 'food') push(x,y, SID.FOOD);
            
            let e = grid.entities[x][y];
            if(e) {
                if(e.type === 'prey') {
                    if(e.isSleeping) push(x,y, SID.PREY_SLP);
                    else if(e.state === 'action') push(x,y, SID.PREY_ACT);
                    else push(x,y, SID.PREY);
                } else {
                    if(e.isSleeping) push(x,y, SID.PRED_SLP);
                    else if(e.state === 'action') push(x,y, SID.PRED_ACT);
                    else push(x,y, SID.PRED);
                }
            }
        }
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, glState.instanceBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, iData.subarray(0, count * 4));
    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, count);
}
</script>
</body>
</html>